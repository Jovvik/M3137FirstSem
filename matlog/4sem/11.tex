\chapter{7 мая}

\section{Гёделева нумерация}

Это кодировка для строк.

\begin{definition}[\(\godel{}\)]\itemfix
	\begin{center}
		\begin{tabular}{|C|C|}
			\hline
			x       & \godel{x}                  \\ \hline
			(       & 3                          \\
			)       & 5                          \\
			,       & 7                          \\
			\with   & 9                          \\
			\lor    & 11                         \\
			\neg    & 13                         \\
			\to     & 15                         \\
			\forall & 17                         \\
			\exists & 19                         \\
			.       & 21                         \\
			f_n^k   & 23 + 6 \cdot 2^n \cdot 3^k \\
			P_n^k   & 23 + 6 \cdot 2^n \cdot 3^k \\
			x_k     & 23 + 6 \cdot 2^k           \\ \hline
		\end{tabular}
	\end{center}
\end{definition}

\begin{example}
	Для формальной арифметики: \((=) = P_0^2, (0) = f_0^0, (') = f_0^1, (+) = f_0^2, (\cdot) = f_1^2\)
\end{example}

\begin{definition}
	\(\godel{a_0 a_1 \dots a_{n - 1}} = 2^{\godel{a_0}} \cdot 3^{\godel{a_1}} \cdots p_n^{\godel{a_{n - 1}}}\), где \(p_i\) --- \(i\)-тое простое число.
\end{definition}

\begin{definition}
	\(\godel{S_0 \dots S_n} = 2^{\godel{S_0}} \cdots p_n^{\godel{S_{n - 1}}}\), где \(S_i\) --- некоторая строка.
\end{definition}

Несложно заметить, что символы всегда нечетные, а строки всегда чётные, что упрощает жизнь. Это не содержательно и сделано только для удобства вычисления ``руками'', т.к. это было сделано до компьютеров.

Таким образом, мы можем взять любую формулу или доказательство и закодировать.

\begin{example}
	\(\godel{a = 0} = 2^{27 + 6} \cdot 3^{25 + 6 \cdot 4} \cdot 5^{23 + 6}\)
\end{example}

\begin{theorem}
	Рассмотрим функцию \[Proof(\underbrace{x}_{\godel{\chi}}, p) = \begin{cases}
			0, & \text{если \(p\) --- гёделев номер доказательства \(\chi\)} \\
			1, & \text{иначе}
		\end{cases} \]
	\(Proof\) рекурсивна.
\end{theorem}

\begin{theorem}
	Если функция представима в формальной арифметике, то она рекурсивна.
\end{theorem}
\begin{proof}
	Рассмотрим \(f : \N \to \N\), представимую в формальной арифметике. Тогда существует \(\varphi\) с \(n + 1\) свободной переменной \((x_1 \dots x_{n+1})\)\footnote{и т.д., см. определение представимой в формальной арифметике функции}.

	Если \(f(k_1 \dots k_n) = k_{n+1}\), то \(\vdash \varphi(\overline{k_1} \dots \overline{k_{n+1}})\), т.е. существует доказательство \(\delta = \delta_1 \dots \delta_t\).
	\[Proof(\godel{\varphi(\overline{k_1} \dots \overline{k_{n+1}})}, \godel{\delta}) = 0\]
	Найдём \(\delta\) и \(\overline{k_{n+1}}\). Переберем \(y\) и будем подставлять \(\text{plog}_2 y\) вместо \(\overline{k_{n+1}}\) и \(\text{plog}_3 y\) вместо \(\delta\). Таким образом, мы переберем все возможные комбинации:

	\[
		S\ev{\text{plog}_2, M\ev{S\ev{Proof, S\ev{Subst_{n + 1}, \godel{\varphi}, P_{n+1}^2, P_{n+1}^3 \dots P_{n+1}^{n + 1}, S\ev{\text{plog}_2, P^1_{n+1}}}, S\ev{\text{plog}_3, P^1_{n+1}}}}}
	\]
	\begin{itemize}
		\item \(S\ev{\text{plog}_2, P^1_{n+2}}\) --- то же самое, что и \(\text{plog}_2 y\).
		\item \(Subst_i\) берёт \(i\)-тый аргумент \(x_i\) и заменяет все вхождения \(x_i\) в во всех аргументах, кроме последнего, на значение последнего аргумента.
	\end{itemize}

	Объяснение: \(M\) найдёт минимальное\footnote{что нам не нужно, но пусть будет} \(y\), такое что при вышеуказанной подстановке \(Proof = 0\). Т.к. нам нужно получить \(k_{n+1}\), то мы берём \(\text{plog}_2\).
\end{proof}

\subsection{Самоприменение}

\begin{definition}
	\(W_1(\godel{\chi}, \godel{p}) = 0\) тогда и только тогда, когда \(p\) --- доказательство самоприменения \(\chi\), т.е. доказательство \(\chi[x_0 : = \godel{\chi}]\); иначе \(W_1 = 1\).
\end{definition}

Представление \(W_1\) в формальной арифметике через \(Subst\) очевидно, обозначим его \(\omega_1\).

Формула \(\sigma(x) = \forall p.\neg \omega_1(x, p)\) утверждает ``самоприменение \(x\) недоказуемо''. Доказуемо ли \(\sigma(\overline{\godel{\sigma}})\)?

\begin{remark}
	Эта тема несколько архаична.
\end{remark}

\begin{definition}
	Теория \textbf{\(\omega\)-непротиворечива}, если для любой \(\varphi(x)\): если \(\vdash \varphi(\overline{0}), \vdash \varphi(\overline{1}) \dots \), то \(\nvdash \exists x.\neg \varphi(x)\)
\end{definition}
\unfinished
