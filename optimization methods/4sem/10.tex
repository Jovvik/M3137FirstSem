\chapter{7 апреля}

Рассмотрим строчно-столбцовый формат.

Используемые структуры:
\begin{enumerate}
    \item Вещественный массив \texttt{di} --- диагональные элементы.
    \item Вещественные массивы \texttt{al} \textit{(по строкам)}, \texttt{au} \textit{(по столбцам)}, хранящие внедиагональные элементы нижнего или верхнего треугольника соответственно.
    \item Целочисленный массив \texttt{ja} --- номера столбцов \textit{(строк)} хранимых внедиагональных элементов нижнего или верхнего треугольника матрицы. \texttt{ja[j]} --- номер столбца для \texttt{al[j]}, номер строки для \texttt{au[j]}.
    \item Целочисленный массив \texttt{ia}, где \texttt{ia[k]} равен индексу \textcolor{red}{\textit{(в нумерации с 1)}}, с которого начинаются элементы \(k\)-той строки или столбца в массивах \texttt{al}, \texttt{au}, \texttt{ja}.
\end{enumerate}

Размерность \texttt{ja}, \texttt{al}, \texttt{au} есть \texttt{ia[n+1]-1}.

\texttt{ia[i] - ia[i]} --- количество хранимых внедиагональных элементов \(i\)-той строки \textit{(столбца)} нижнего \textit{(верхнего)} треугольника.

\texttt{ia[1] = ia[2] = 1}.

\begin{example}
    \[\begin{bmatrix}
            a_{11} &                                                                       \\
                   & a_{22} & a_{23} & a_{24}                                              \\
                   & a_{32} & a_{33} & 0      & a_{35} & a_{36}                            \\
                   & a_{42} & 0      & a_{44} & a_{45} & 0      & a_{47}                   \\
                   &        & a_{53} & a_{54} & a_{55} & a_{56} & 0      & a_{58} & a_{59} \\
                   &        & a_{63} & 0      & a_{65} & a_{66} & 0      & a_{68} & 0      \\
                   &        &        & a_{74} & 0      & 0      & a_{77} & 0      & a_{79} \\
                   &        &        &        & a_{85} & a_{86} & 0      & a_{88} & 0      \\
                   &        &        &        & a_{95} & 0      & a_{97} & 0      & a_{99}
        \end{bmatrix} \]
    \[di = \{a_{11}, a_{22}, a_{33}, a_{44}, a_{55}, a_{66}, a_{77}, a_{88}, a_{99}\}\]
    \[ia = \{1, 1, 1, 2, 3, 5, 7, 8, 10, 12\}\]
    \[ja = \{2, 2, 3, 4, 3, 5, 4, 5, 6, 5, 7\}\]
    \[al = \{a_{32}, a_{42}, a_{53}, a_{54}, a_{63}, a_{65}, a_{74}, a_{85}, a_{86}, a_{95}, a_{97}\}\]
    \[au = \{a_{23}, a_{24}, a_{35}, a_{45}, a_{36}, a_{56}, a_{47}, a_{58}, a_{68}, a_{59}, a_{79}\}\]

    Для 6-ой строки: \(ia[6] = 5\) --- начало 6-ой строки в массивах \(ja\) и \(al\). \(ia[6 + 1] - ia[6] = 7 - 5 = 2\) --- количество элементов в 6-ой строке.

    Первый элемент: \(ja[ia[6]] = ja[5] = 3\), второй элемент: \(ja[ia[6] + 1] = ja[5 + 1] = 5\).
\end{example}


\section{Решение СЛАУ. Метод Гаусса.}

СЛАУ:
\begin{equation}
    \label{СЛАУ}
    \begin{cases}
        a_{11} x_1 + a_{12} x_2 + \dots + a_{1n} x_n = b_1 \\
        a_{21} x_1 + a_{22} x_2 + \dots + a_{2n} x_n = b_2 \\
        \vdots                                             \\
        a_{n1} x_1 + a_{n2} x_2 + \dots + a_{nn} x_n = b_n \\
    \end{cases}
\end{equation}

То же самое, но в матричной форме:
\[Ax = b\]
, где:
\begin{itemize}
    \item \(A = (a_{ij})_{i,j = 1}^n\) --- вещественные числа
    \item \(b = (b_1 \dots b_n)^T\)
    \item \(x = (x_1 \dots x_n)^T\)
\end{itemize}

Эффективность способов решения СЛАУ зависит от структуры и свойств матрицы \(A\), т.е. от размера, обусловленности, симметричности, заполненности и от её профиля.

Рассмотрим прямой ход метода Гаусса. Первый шаг --- домножение уравнений на коэффициенты \( - \frac{a_{21}}{a_{11}}, - \frac{a_{31}}{a_{11}} \dots - \frac{a_{n1}}{a_{11}}\):

\begin{equation}
    \label{СЛАУ первый шаг}
    \begin{cases}
        a_{11} x_1 + a_{12} x_2 + \dots + a_{1n} x_n = b_1      \\
        a_{22}^{(1)} x_2 + \dots + a_{2n}^{(1)} x_n = b_2^{(1)} \\
        \vdots                                                  \\
        a_{n2}^{(1)} x_2 + \dots + a_{nn}^{(1)} x_n = b_n^{(1)} \\
    \end{cases}
\end{equation}
\[a_{ij}^{(1)} = a_{ij} - \frac{a_{i1}}{a_{11}} a_{1j} \quad b_i^{(1)} = b_i - \frac{a_{i1}}{a_{11}} b_1 \]

На \(n - 1\) шаге метода система будет приведена к следующему виду:

\begin{equation}
    \begin{cases}
        a_{11} x_1 + a_{12} x_2 + a_{13} x_3 + \dots + a_{1n} x_n = b_1            \\
        a_{22}^{(1)} x_2 + a_{23}^{(1)} x_3 + \dots + a_{2n}^{(1)} x_n = b_2^{(1)} \\
        \vdots                                                                     \\
        a_{nn}^{(n - 1)} x_n = b_n^{(n - 1)}                                       \\
    \end{cases}
\end{equation}

Дальше производятся обратный ход метода Гаусса:
\[x_n = \frac{b_n^{(n - 1)}}{a_{nn}^{(n - 1)}}\]
\[\vdots\]
\[x_2 = \frac{b_2^{(1)} - a_{23}^{(1)} x_3 - \dots - a_{2n}^{(1)} x_n}{a_{22}^{(1)}}\]
\[x_1 = \frac{b_1 - a_{12} x_2 - \dots - a_{1n} x_n}{a_{11}}\]
В общем виде:
\[x_k = \frac{1}{a_{kk}^{(k - 1)}} \left( b_k^{(k - 1)} - \sum_{j = k + 1}^n a_{kj}^{(k - 1)} \cdot x_j \right)\]

Алгоритм:
\renewcommand{\theFancyVerbLine}{\sffamily \small\arabic{FancyVerbLine}}
\begin{minted}[escapeinside=||,mathescape=true,linenos]{python}
for |$k = 1 \dots n-1$|:
    for |$i = k+1 \dots n$|:
        |$t_{ik} = a_{ik}/a_{kk}$|
        |$b_i = b_i - t_{ik} b_k$|
        for |$j = k+1 \dots n $|
            |$a_{ij} = a_{ij} - t_{ik} \cdot a_{kj}$|
|$x_n = b_n/a_{nn}$|
for |$k = n - 1 \dots 1$|
    |$x_k = \left( b_k - \sum_{j = k + 1}^n a_{kj} \cdot x_j \right) / a_{kk}$|
\end{minted}

У этого алгоритма есть проблема --- арифметика компьютеров не точна. В частности, если \(a_{kk}\) мало, то при делении можно получить немалую ошибку. Чтобы бороться с этим, есть модификация:

\subsection{Модификация метода Гаусса \textit{(постолбцовый выбор главного элемента)}}

Необходимо найти \(m \geq k\), где \(k\) --- номер рассматриваемого шага, а \(|a_{mk}| = \max_{i \geq k} \{|a_{ik}|\} \).

\begin{itemize}
    \item Если \(a_{mk} = 0 (\approx \varepsilon)\), однозначного решения нет, остановка алгоритма.
    \item Если \(a_{mk} \neq 0\), меняем местами \(b_k\) и \(b_m\); \(a_{kj}\) и \(a_{mj}\) при \(j = k \dots n\).
\end{itemize}

При такой замене порядок \(x_i\) в общем векторе решения не меняются. Есть и другие модификации, которые его меняют. В таких алгоритмах необходимо поддерживать матрицу перестановок неизвестных и умножить ответ на эту матрицу.