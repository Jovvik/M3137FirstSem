\chapter{7 октября}

\section{Методы модификации и комбинирования кодов}

Мы не хотим строить сложные коды целиком, проще комбинировать коды поменьше.

\subsection{Конструкция Плоткина}

Пусть дано два кода \(C_1\) и \(C_2\) : \((n, k_i, d_i)\).
Построим тогда код \(C = \{(c_1, c_1 + c_2 \mid c_i \in C_i, i \in \{1, 2\})\}\).
Тогда этот код \((2n, k_1 + k_2, \min(2d_1, d_2))\).

Порождающая матрица этого кода, если \(G_1\) --- порождающая матрица для \(C_1\) и \(G_2\) --- для \(C_2\):
\[G = \begin{pmatrix}
    G_1 & G_1 \\
    0 & G_2
\end{pmatrix}\]
\begin{proof}
    \(C\) содержит кодовые слова вида \((c_1, c_1) \mid c_1 \in C_1\) и вида \((0, c_2) \mid c_2 \in C_2\),
    следовательно, \(d \leq 2d_1\) и \(d \leq d_2\)

    Пусть \(c_1, c_1' \in C_1 \setminus \{0\}\) и \(c_2, c_2' \in C_2 \setminus \{0\}\)
    --- ненулевые слова компонентных кодов.

    \[d((c_1, c_1 + c_2), (c_1', c_1' + c_2')) = d(c_1, c_1') + d(c_1 + c_2, c_1' + c_2')\]
    \[\?\]
\end{proof}

Будем декодировать \((y', y'') = (c_1, c_1 + c_2) + (e', e'')\) в метрике Хэмминга.
\[y''' = y'' - y' = c_1 + c_2 + e'' - c_1 - e' = c_2 + e'''\]
Продекодируем получившийся \(y'''\) в коде \(C_2\).
Если \(\wt((e', e'')) \leq \floor{(d - 1)/2}\)
, то \(\wt(e''') \leq \wt(e') + \wt(e'') \leq \floor{(d - 1)/2} \leq \floor{(d_2 - 1)/2}\) и декодирование успешно, т.е. мы получим \(c_2\).

Предположим, что \(c_2\) получено правильно.
Продекодируем в \(C_1\) вектора \(y' = c_1 + e'\) и \(y'' - c_2 = c_1 + e\).
Если \(\wt((e', e'')) \leq \?\)
, то декодирование \(y'\) или \(y''\) даст правильный результат. % почему?

\subsubsection{Коды Рида-Маллера}

Это семейство кодов определяется рекурсивным применением конструкции Плоткина.
Код Рида-Маллера порядка \(r\) длины \(2^m\) обозначается как \(RM(r, m)\).

Код \(RM(0, m)\) --- код \((2^m, 1, 2^m)\). Код \(RM(m,m)\) --- \((2^m, 2^m, 1)\).

Код \(RM(r + 1, m + 1)\) получается применением конструкции Плоткина к
\(RM(r + 1, m)\) и \(RM(r, m)\).

Недавно было доказано, что коды Рида-Маллера оптимальны в том смысле, что он достигает границы Шеннона для двоичного канала с АБГШ и некоторых других каналов.
Проблема этих кодов в том, что их сложно эффективно декодировать.

\subsection{Модификации кодов}

\subsubsection{Укорочение}

Укороченный код получается путем выбора кодовых слов исходного кода,
содержащий нули на заданных позициях. Эти нули удаляются.

Если дан \((n, k, d)\) код с \(G = (I \mid A)\),
то мы удаляем из порождающей матрицы \(m\) столбцов единичной подматрицы и соответствующие им \(m\) строк.
Если появятся нулевые столбцы, то мы их тоже удаляем.
Таким образом получится порождающая матрица \((\leq n - m, k - m, \geq d)\) кода.

\subsubsection{Выкалывание}

Удалим из всех кодовых слов заданные символы (обычно проверочных \?).

Если дан \((n, k, d)\) код с \(H = (A \mid - I)\),
то удалим из \(H\) \(m\) столбцов единичной подматрицы и соответствующие им \(m\) строк.
Если появятся линейно зависимые строки, то мы их тоже удаляем.
Тогда мы получим \((n - m, \leq k, \geq d - m)\) код.

Пример: таким образом можно построить оптимальный код \((10, 3, 5)\).
% todo: возможно стоить напистаь как

\subsubsection{Расширение}

Наиболее распространенный способ --- проверки на четность,
так мы получаем из \((n,k,d)\) кода \((n + 1, k, d')\) код.

Если \(d\) нечетно, то \(d' = d + 1\), иначе\footnote{Мне так кажется} \(d' = d\).

\subsection{Каскадные коды}

Перемежитель переставляет символы таким образом,
чтобы последствия ошибочного декодирования одного кода могут быть легко ликвидированы декодером другого кода.
% todo: объяснить по человечески

\subsection{Прямое произведение кодов}

Для двух заданных кодов \((n_1, k_1, d_1)\) и \((n_2, k_2, d_2)\)
построим прямое произведение этих двух кодов
--- один из кодов будет декодировать по строчкам, а другой --- по столбцам.

Порождающая матрица такого кода будет иметь вид
\[G' \xor G'' = \begin{pmatrix}
    G_{11}' G'' & G_{12}' G'' & \ldots & G_{1n_1}' G'' \\
    G_{21}' G'' & G_{22}' G'' & \ldots & G_{2n_1}' G'' \\
    \vdots & \vdots & \ddots & \vdots \\
    G_{k_1 1}' G'' & G_{k_1 2}' G'' & \ldots & G_{k_1n_1}' G''
\end{pmatrix}\]

Пропускная способность такого кода будет равна
\[R = \frac{k_1k_2}{n_1n_2} < \frac{k_1}{n_1}, \frac{k_2}{n_2}\]
% todo: тут был комментарий на лекции

Код способен исправить многие \textit{(но не все)} ошибки веса большего,
чем \(d_1d_2 / 2\).

Алгоритм декодирования можно паралеллизировать.

\subsubsection{Пример: код Рао-Редди \((48,31,8)\)}

РЖД использует этот код для передачи данных машинисту.

Рассмотрим прямое произведение расширенного \((16,11,4)\) кода Хемминга \(C_1\) и
\((3,2,2)\) кода \(C_2\) с проверкой на четность.
Получится код \((48,22,8)\).

Дополним этот код кодовыми словами кода Рида-Маллера \((16, 5, 8)\) \(C_3\),
к которым дописали \(32\) нуля в конец для размерности.

Тогда кодовые слова будут иметь вид \((c_1 + c_3, c_2, c_1 + c_2) \mid c_1, c_2 \in C_1, c_3 \in C_3\).
% todo: почему?

Вес кодового слова \( \geq 8\), т.к.:
\begin{itemize}
    \item \?
    \item \?
\end{itemize}

Теперь получен код \((48, 27, 8)\).

Пусть \(C_4\) --- код с порождающей матрицей \?.

Итого код \((48, 31, 8)\) Рао-Редди состоит из кодовых слов вида:
\[(c_1 + c_3 + c_4,c_2 + c_4,c_1 + c_2 + c_4) \mid c_1,c_2 \in C_1, c_3 \in C_3, c_4 \in C_4\]

Вывод: создание кодов больше похоже на искусство,
непонятно что лучше сработает.

\subsection{Лестничные коды}

\? % что-то про то, что плохой код бывает лучше и GF(q^k)

\subsection{Граница Зяблова}

Выберем внутренний \((n,k,d)\) код на границе Варшамова--Гилберта
с \(r = k / n \geq 1 - h(d / n) = 1 - \delta\).

\?

\subsection{Обобщенные каскадные коды (Блох, Зяблов, Зиновьев)}

\? внешние \((N, K_i, D_i)\) коды \(\mathcal{A}_i\) над \(GF(q^{m_i}) \mid 1 \leq i \leq s\).

\? вложенные внутренние \((n, k_i, d_i)\) коды
\(\mathcal{B}_i : \mathcal{B}_1 \supset \mathcal{B}_2 \supset \dots \supset \mathcal{B}_s\) над \(GF(q)\), при этом \(k_i - k_{i+1} = m_i\) и код
\(\mathcal{B}_i\) порождается последними \(k_i\) строками \(k_1 \times m\) матрицы \(B\).

Кодирование: \?

\?

Декодирование: \?

\subsection{Турбо--коды}

Будем кодировать данные сразу двумя сверточными кодами.

\?

Минимальное расстояние растет с увеличением длины крайне медленно
и начиная с некоторого места перестает расти.
Поэтому использовать длинные турбо--коды неразумно.

\?

\subsection{Построение перемежителей}

Давайте найдем, как перемежитель должен переставлять символы.

Будем переставлять близкие позиции во входной последовательности
в максимально удаленные позиции в выходной последовательности:
\[0 < |i - j|< d \Rightarrow |\pi(i) - \pi(j)| \geq S\]

\begin{itemize}
    \item  Можно генерировать случайные перестановки и отбрасывать неэффективные.
        Но это долго.
    \item  Табличный перемежитель:
        запишем все символы в квадратную матрицу по строкам,
        а прочитаем ее по столбцам.
    \item Перестановочный полином:
        если \?
\end{itemize}

Перемежитель в целом нужен когда мы делаем композицию декодеров,
т.к. канал с декодером на нем уже не является каналом с АБГШ.

\?